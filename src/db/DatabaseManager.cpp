#include "DatabaseManager.h"
#include <QSqlDatabase>
#include <QSqlQuery>
#include <QSqlError>
#include <QMessageBox>
#include <QApplication>
#include <QDebug>

DatabaseManager* DatabaseManager::instance = nullptr;

DatabaseManager::DatabaseManager(QObject *parent) : QObject(parent)
{
    // Vérifier les drivers disponibles
    QStringList drivers = QSqlDatabase::drivers();
    qDebug() << "Drivers SQL disponibles:" << drivers;

    // Utiliser Oracle (QOCI) comme driver principal
    if (drivers.contains("QOCI")) {
        database = QSqlDatabase::addDatabase("QOCI");
        qDebug() << "Utilisation du driver QOCI (Oracle)";
    } else {
        // Fallback vers QODBC si QOCI n'est pas disponible
        database = QSqlDatabase::addDatabase("QODBC");
        qDebug() << "Utilisation du driver QODBC en fallback";
    }
}

DatabaseManager* DatabaseManager::getInstance()
{
    if (instance == nullptr) {
        instance = new DatabaseManager();
    }
    return instance;
}

DatabaseManager::~DatabaseManager()
{
    disconnectFromDatabase();
}

bool DatabaseManager::connectToDatabase()
{
    // Vérifier les drivers disponibles à nouveau avant la connexion
    QStringList drivers = QSqlDatabase::drivers();
    qDebug() << "Drivers SQL disponibles avant connexion:" << drivers;
    
    // Afficher où Qt cherche les plugins
    qDebug() << "Qt Library Paths:" << QApplication::libraryPaths();
    
    // Tentative de chargement manuel du pilote
    QApplication::addLibraryPath(QApplication::applicationDirPath() + "/sqldrivers");
    QApplication::addLibraryPath(QApplication::applicationDirPath());
    
    // Configuration Oracle
    database.setHostName("localhost");
    database.setDatabaseName("XE");
    database.setUserName("system");
    database.setPassword("++652100"); 
    database.setPort(1521);
    
    qDebug() << "Tentative de connexion Oracle avec: "
             << "Driver=" << database.driverName()
             << "Host=" << database.hostName()
             << "DB=" << database.databaseName()
             << "User=" << database.userName()
             << "Port=" << database.port();

    if (!database.open()) {
        QString error = "Erreur de connexion à la base de données Oracle:\n" + database.lastError().text();
        showDatabaseError(error);
        return false;
    }

    qDebug() << "Connexion à Oracle réussie !";
    
    // Vérifier si les tables existent déjà et les créer seulement si nécessaire
    if (!checkTablesExist()) {
        qDebug() << "Tables non trouvées, création des tables...";
        createTables();
    } else {
        qDebug() << "Tables existantes trouvées, connexion prête à l'utilisation.";
    }
    
    return true;
}

void DatabaseManager::disconnectFromDatabase()
{
    if (database.isOpen()) {
        database.close();
        qDebug() << "Déconnexion de la base de données";
    }
}

bool DatabaseManager::isConnected()
{
    return database.isOpen();
}

void DatabaseManager::showDatabaseError(const QString& message)
{
    QMessageBox::critical(nullptr, "Erreur de base de données", message);
    qCritical() << message;
}

QSqlQuery DatabaseManager::executeQuery(const QString& queryString)
{
    QSqlQuery query(database);
    if (!query.exec(queryString)) {
        QString error = "Erreur d'exécution de la requête:\n" + query.lastError().text();
        showDatabaseError(error);
    }
    return query;
}

QSqlQuery DatabaseManager::executePreparedQuery(const QString& queryString, const QVariantList& values)
{
    QSqlQuery query(database);
    query.prepare(queryString);

    for (const QVariant& value : values) {
        query.addBindValue(value);
    }

    if (!query.exec()) {
        QString error = "Erreur d'exécution de la requête préparée:\n" + query.lastError().text();
        showDatabaseError(error);
    }

    return query;
}

bool DatabaseManager::beginTransaction()
{
    return database.transaction();
}

bool DatabaseManager::commitTransaction()
{
    return database.commit();
}

bool DatabaseManager::rollbackTransaction()
{
    return database.rollback();
}

QString DatabaseManager::getLastError()
{
    return database.lastError().text();
}

// Méthodes pour la création des tables et l'insertion des données
// Puisque la base de données est déjà créée et remplie, ces méthodes retournent simplement true

bool DatabaseManager::createTables()
{
    qDebug() << "Début de la création des tables Oracle...";
    
    // NE PAS supprimer les tables existantes - préserver les données
    // Les tables seront créées seulement si elles n'existent pas
    
    // Créer la table LIVREURS avec TOUS les champs
    QString createLivreurs = R"(
        CREATE TABLE LIVREURS (
            ID_LIVREUR NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            NOM VARCHAR2(100) NOT NULL,
            TELEPHONE VARCHAR2(20) NOT NULL,
            ZONE_LIVRAISON VARCHAR2(100) NOT NULL,
            VEHICULE VARCHAR2(50) NOT NULL,
            DISPONIBILITE NUMBER(1) DEFAULT 1 CHECK (DISPONIBILITE IN (0,1)),
            CREATED_AT DATE DEFAULT SYSDATE,
            UPDATED_AT DATE DEFAULT SYSDATE
        )
    )";
    
    QSqlQuery queryLivreurs(database);
    qDebug() << "Tentative de création table LIVREURS...";
    if (!queryLivreurs.exec(createLivreurs)) {
        // Si la table existe déjà, ce n'est pas une erreur
        QString error = queryLivreurs.lastError().text();
        if (error.contains("name is already used by an existing object") || 
            error.contains("ORA-00955")) {
            qDebug() << "Table LIVREURS existe déjà - OK";
        } else {
            qDebug() << "Erreur création table LIVREURS:" << error;
            return false;
        }
    } else {
        qDebug() << "Table LIVREURS créée avec succès";
    }
    
    // Créer la table COMMANDES
    QString createCommandes = R"(
        CREATE TABLE COMMANDES (
            ID_COMMANDE NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            DATE_COMMANDE DATE NOT NULL,
            STATUT VARCHAR2(50) DEFAULT 'En attente' CHECK (STATUT IN ('En attente', 'En cours', 'Livree', 'Annulee')),
            VILLE_LIVRAISON VARCHAR2(100) NOT NULL,
            ID_CLIENT NUMBER NOT NULL,
            ID_LIVREUR NUMBER,
            CREATED_AT DATE DEFAULT SYSDATE,
            UPDATED_AT DATE DEFAULT SYSDATE,
            CONSTRAINT FK_COMMANDES_LIVREUR FOREIGN KEY (ID_LIVREUR) REFERENCES LIVREURS(ID_LIVREUR) ON DELETE CASCADE
        )
    )";
    
    QSqlQuery queryCommandes(database);
    qDebug() << "Tentative de création table COMMANDES...";
    if (!queryCommandes.exec(createCommandes)) {
        // Si la table existe déjà, ce n'est pas une erreur
        QString error = queryCommandes.lastError().text();
        if (error.contains("name is already used by an existing object") || 
            error.contains("ORA-00955")) {
            qDebug() << "Table COMMANDES existe déjà - OK";
        } else {
            qDebug() << "Erreur création table COMMANDES:" << error;
            return false;
        }
    } else {
        qDebug() << "Table COMMANDES créée avec succès";
    }
    
    // Créer des index (ils seront ignorés s'ils existent déjà)
    createIndexes();
    
    // Mettre à jour les contraintes pour la suppression en cascade
    updateForeignKeyConstraints();
    
    qDebug() << "Vérification/Création des tables terminée avec succès";
    return true;
}

bool DatabaseManager::checkTablesExist()
{
    // Vérifier si les tables principales existent
    QSqlQuery query(database);
    query.prepare("SELECT COUNT(*) FROM USER_TABLES WHERE TABLE_NAME IN ('LIVREURS', 'COMMANDES')");
    
    if (!query.exec()) {
        qDebug() << "Erreur lors de la vérification des tables:" << query.lastError().text();
        return false;
    }
    
    if (query.next()) {
        int tableCount = query.value(0).toInt();
        qDebug() << "Nombre de tables trouvées:" << tableCount;
        return tableCount >= 2; // Les deux tables principales existent
    }
    
    return false;
}

void DatabaseManager::createIndexes()
{
    // Créer des index et triggers pour l'auto-update
    QStringList indexQueries = {
        "CREATE INDEX IDX_LIVREURS_NOM ON LIVREURS(NOM)",
        "CREATE INDEX IDX_LIVREURS_ZONE ON LIVREURS(ZONE_LIVRAISON)",
        "CREATE INDEX IDX_LIVREURS_DISPONIBILITE ON LIVREURS(DISPONIBILITE)",
        "CREATE INDEX IDX_COMMANDES_STATUT ON COMMANDES(STATUT)",
        "CREATE INDEX IDX_COMMANDES_DATE ON COMMANDES(DATE_COMMANDE)",
        "CREATE INDEX IDX_COMMANDES_VILLE ON COMMANDES(VILLE_LIVRAISON)",
        "CREATE INDEX IDX_COMMANDES_LIVREUR ON COMMANDES(ID_LIVREUR)"
    };
    
    for (const QString& indexQuery : indexQueries) {
        QSqlQuery query(database);
        if (!query.exec(indexQuery)) {
            // Les index existants ne sont pas une erreur
            QString error = query.lastError().text();
            if (error.contains("name is already used by an existing object") || 
                error.contains("ORA-00955")) {
                qDebug() << "Index existe déjà - OK";
            } else {
                qDebug() << "Erreur création index:" << error;
            }
        } else {
            qDebug() << "Index créé avec succès";
        }
    }
}

void DatabaseManager::updateForeignKeyConstraints()
{
    qDebug() << "Mise à jour des contraintes de clé étrangère pour CASCADE...";
    
    // Vérifier si la contrainte actuelle existe et la supprimer si nécessaire
    QSqlQuery checkConstraint(database);
    checkConstraint.exec("SELECT constraint_name FROM user_constraints WHERE table_name = 'COMMANDES' AND constraint_type = 'R'");
    
    QStringList constraintsToUpdate;
    while (checkConstraint.next()) {
        QString constraintName = checkConstraint.value(0).toString();
        constraintsToUpdate.append(constraintName);
        qDebug() << "Contrainte trouvée:" << constraintName;
    }
    
    // Supprimer TOUTES les anciennes contraintes de clé étrangère
    for (const QString& constraintName : constraintsToUpdate) {
        QSqlQuery dropConstraint(database);
        QString dropQuery = QString("ALTER TABLE COMMANDES DROP CONSTRAINT %1").arg(constraintName);
        if (dropConstraint.exec(dropQuery)) {
            qDebug() << "Ancienne contrainte supprimée:" << constraintName;
        } else {
            qDebug() << "Erreur suppression contrainte:" << dropConstraint.lastError().text();
        }
    }
    
    // Ajouter la nouvelle contrainte CASCADE
    QSqlQuery addConstraint(database);
    QString addConstraintQuery = R"(
        ALTER TABLE COMMANDES 
        ADD CONSTRAINT FK_COMMANDES_LIVREUR_CASCADE 
        FOREIGN KEY (ID_LIVREUR) REFERENCES LIVREURS(ID_LIVREUR) ON DELETE CASCADE
    )";
    
    if (addConstraint.exec(addConstraintQuery)) {
        qDebug() << "Nouvelle contrainte CASCADE ajoutée avec succès";
    } else {
        QString error = addConstraint.lastError().text();
        if (error.contains("name is already used by an existing object") || 
            error.contains("ORA-00955")) {
            qDebug() << "Contrainte CASCADE existe déjà - OK";
        } else {
            qDebug() << "Erreur ajout contrainte CASCADE:" << error;
            
            // Si échec, essayer avec un nom différent
            QSqlQuery addConstraint2(database);
            QString addConstraintQuery2 = R"(
                ALTER TABLE COMMANDES 
                ADD CONSTRAINT FK_COMM_LIVR_CASCADE 
                FOREIGN KEY (ID_LIVREUR) REFERENCES LIVREURS(ID_LIVREUR) ON DELETE CASCADE
            )";
            
            if (addConstraint2.exec(addConstraintQuery2)) {
                qDebug() << "Contrainte CASCADE ajoutée avec nom alternatif";
            } else {
                qDebug() << "Échec total ajout contrainte CASCADE:" << addConstraint2.lastError().text();
            }
        }
    }
}

bool DatabaseManager::insertSampleData()
{
    // Vérifier d'abord si des données existent déjà
    QSqlQuery checkQuery(database);
    checkQuery.exec("SELECT COUNT(*) FROM LIVREURS");
    if (checkQuery.next() && checkQuery.value(0).toInt() > 0) {
        qDebug() << "Des données existent déjà dans LIVREURS, pas d'insertion de données de test";
        return true;
    }
    
    qDebug() << "Insertion de données de test...";
    
    // Insérer des livreurs de test avec TOUS les champs
    QStringList livreursData = {
        "INSERT INTO LIVREURS (NOM, TELEPHONE, ZONE_LIVRAISON, VEHICULE, DISPONIBILITE) VALUES ('Ahmed Ben Ali', '22123456', 'Tunis Centre', 'Moto Yamaha', 1)",
        "INSERT INTO LIVREURS (NOM, TELEPHONE, ZONE_LIVRAISON, VEHICULE, DISPONIBILITE) VALUES ('Fatma Khalil', '98765432', 'Ariana', 'Voiture Peugeot', 1)",
        "INSERT INTO LIVREURS (NOM, TELEPHONE, ZONE_LIVRAISON, VEHICULE, DISPONIBILITE) VALUES ('Mohamed Sassi', '55666777', 'Sfax Nord', 'Camionnette', 0)",
        "INSERT INTO LIVREURS (NOM, TELEPHONE, ZONE_LIVRAISON, VEHICULE, DISPONIBILITE) VALUES ('Leila Trabelsi', '20304050', 'Sousse Centre', 'Moto Honda', 1)",
        "INSERT INTO LIVREURS (NOM, TELEPHONE, ZONE_LIVRAISON, VEHICULE, DISPONIBILITE) VALUES ('Karim Mansouri', '70809090', 'Monastir', 'Voiture Renault', 1)"
    };
    
    for (const QString& livreurQuery : livreursData) {
        QSqlQuery query(database);
        if (!query.exec(livreurQuery)) {
            qDebug() << "Erreur insertion livreur:" << query.lastError().text();
            return false;
        }
        qDebug() << "Livreur inséré avec succès";
    }
    
    // Insérer des commandes de test
    QStringList commandesData = {
        "INSERT INTO COMMANDES (DATE_COMMANDE, STATUT, VILLE_LIVRAISON, ID_CLIENT, ID_LIVREUR) VALUES (SYSDATE-5, 'Livree', 'Tunis', 1001, 1)",
        "INSERT INTO COMMANDES (DATE_COMMANDE, STATUT, VILLE_LIVRAISON, ID_CLIENT, ID_LIVREUR) VALUES (SYSDATE-3, 'En cours', 'Ariana', 1002, 2)",
        "INSERT INTO COMMANDES (DATE_COMMANDE, STATUT, VILLE_LIVRAISON, ID_CLIENT, ID_LIVREUR) VALUES (SYSDATE-10, 'En cours', 'Sfax', 1003, 3)",
        "INSERT INTO COMMANDES (DATE_COMMANDE, STATUT, VILLE_LIVRAISON, ID_CLIENT, ID_LIVREUR) VALUES (SYSDATE-1, 'En attente', 'Sousse', 1004, NULL)",
        "INSERT INTO COMMANDES (DATE_COMMANDE, STATUT, VILLE_LIVRAISON, ID_CLIENT, ID_LIVREUR) VALUES (SYSDATE-2, 'En cours', 'Monastir', 1005, 5)",
        "INSERT INTO COMMANDES (DATE_COMMANDE, STATUT, VILLE_LIVRAISON, ID_CLIENT, ID_LIVREUR) VALUES (SYSDATE, 'En attente', 'Tunis', 1006, NULL)",
        "INSERT INTO COMMANDES (DATE_COMMANDE, STATUT, VILLE_LIVRAISON, ID_CLIENT, ID_LIVREUR) VALUES (SYSDATE-7, 'Livree', 'Gabes', 1007, 4)"
    };
    
    for (const QString& commandeQuery : commandesData) {
        QSqlQuery query(database);
        if (!query.exec(commandeQuery)) {
            qDebug() << "Erreur insertion commande:" << query.lastError().text();
            return false;
        }
        qDebug() << "Commande insérée avec succès";
    }
    
    qDebug() << "Données de test insérées avec succès";
    return true;
}

void DatabaseManager::initializeDatabaseWithSampleData()
{
    if (isConnected()) {
        insertSampleData();
    } else {
        qDebug() << "Base de données non connectée, impossible d'insérer des données de test";
    }
}

void DatabaseManager::forceUpdateConstraints()
{
    if (isConnected()) {
        qDebug() << "Forçage de la mise à jour des contraintes...";
        updateForeignKeyConstraints();
    } else {
        qDebug() << "Base de données non connectée, impossible de mettre à jour les contraintes";
    }
}
